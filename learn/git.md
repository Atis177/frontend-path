# Система контроля версий: Git и GitHub
Без системы контроля версий сложно представить современную разработку. Мы использует Гит и Гитхаб.

Нужно уметь работать с гитом из командной строки, понимать терминологию и общепринятые методики.

Программы с графическим интерфейсом ([PHPStorm](https://www.jetbrains.com/help/phpstorm/2016.1/using-git-integration.html), [GitHub Desktop](desktop.github.com), [Tower](https://www.git-tower.com/) и пр.) могут увеличить скорость работы, но применять их рекомендуется только после того, когда будет понятно, как работать с гитом из командной строки.

Без командной строки не обойтись, в гите слишком много операций, чтобы делать для них кнопки. GUI-инструменты стоит рассматривать как средства, упрощающие рутинные задачи, а не как полноценную замену командной строке.

Система контроля версий довольно сложная штука. Чтобы с ней хорошо разобраться нужно время. Запаситесь терпением, проходите разные курсы, читайте книги и не бойтесь задавать вопросы старшим товарищам. Лучше 10 раз переспросить и на 11-й понять, чем погрязнуть в дремучем неведении.

## Учебные материалы
### Курсы
* [Git Real I](https://www.codeschool.com/courses/git-real)
* [Git Real II](https://www.codeschool.com/courses/git-real-2)
* [Mastering GitHub](https://www.codeschool.com/courses/mastering-github)

### Книги
* [Pro Git](https://git-scm.com/book/ru/v2)

### Документация
* [Правила работы с Гитом в Oggetto](http://w.oggettoweb.com/index.php?title=%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_git)

## Инструменты
* [GitHub Desktop](https://desktop.github.com/) — графический интерфейс для Мака и Винды. Рекомендуется использовать для настройки ключей в гит-репозитории (просто залогиниться в программу под своим Гитхаб-аккаунтом и не надо заморачиваться с ssh-сертификатами). Как инструмент лучше использовать постоянно уже после уверенной работы с командной строкой.


## Документация
`git help` — документация по использованию гита.
`git help commit` — показать документацию по команде.

`git init` — инициализировать репозиторий.
`git status`
`git add` — добавить в staging area (подготовка).
`git commit -m "Add styles for header"` — добавляет в репозиторий изменения из staging area.
`git log` — показать список последних изменений. Можно искать (`/`), переходить к следующему вхождению (`n`). Это Vim в visual mode, как документация по команде в баше (например, `man ls`).
`git log --oneline -p` — показать историю коммитов с измененным кодом (`-p` — patch).
`git log --pretty=oneline` — выводить данные по комитам в одну строку.
`git log --pretty=format:"%h %ad- %s [%an]"` — задать свой формат вывода.
%ad — author date
%an — author name
%h — SHA hash
%s — subject
%d — ref names
`git log --oneline --stat` — показать кол-во вставок и удалений в измененных файлах.
`git log --oneline --graph` — показать в виде дерева.
`git log --until=1.minute.ago` — последнюю минуту не учитывать
`git log --since=1.day.ago` — начиная со вчера
`git log --since=1.month.ago --until=1.day.ago` — месяц без вчерашнего дня (относительный промежуток).
`git log --since=2016-01-01 --until=2016-04-01` — с января по апрель (асболютный промежуток).

## Настройка
`git config --list` — показать текущие настройки.
`~/.gitconfig` — файл конфигурации.
`git config --global core.editor sublime -n -w` — изменить редактор для редактирования сообщений в комитах.

`git config --global alias.lol "log --graph --decorate --pretty=oneline --abbrev-commit --all"` — задать аллиас для команды с опциями.

Часто используемые алиасы:
`git config --global alias.st status`
`git config --global alias.co checkout`
`git config --global alias.br branch`
`git config --global alias.ci commit`



## Термины
Папка `.git` — системная папка, в которой гит хранит историю и другую техническую информацию.
`staging area` — здесь хранятся изменения, которые попадут в репозиторий при комите.
`untracked` — файл существует, но не добавлен ни в репозиторий, ни в staging area.
`SHA hash` — набор букв и цифр, идентифицирующих комит.
`HEAD` — ссылка на последний комит в текущей ветке. По умолчанию ссылается на самый последний.
`HEAD^` — предпоследний комит. Есть еще `HEAD^^` — пред-предпоследний комит.
`HEAD~5` — 5 комитов назад.

## Staging Area
`git add fileName` — добавить в SA.
`git add --all` — добавить все изменения и новые файлы в SA. Так же работает `git add .`.
`git reset myFile.html` — убрать добавленный в staging area файл из staging area. Изменеия в файле не потеряются, просто они не будут учтены при комите.
`git add *.txt` — добавить все файлы `.txt` из _текущего каталога_.
`git add "*.txt"` — добавить все файлы `.txt` _из всего проекта_.

## Commit
Сообщения о комитах добны быть в настоящем времени: Добавить файл, Изменить мыло. комит должен ответить на вопрос, что он делает, а не что он сделал. Подробнее см. в [Вики](http://w.oggettoweb.com/index.php?title=%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_git).

`git commit -am "Fix login error message"` — зафиксировать изменения в репозитории. `-a` — добавить в staging area изменения (чтобы не делать отдельно `git add`). `-m` — тут же в добавить сообщение.
`git checkout -- filename.html` — убрать изменения в `filename.html` до последнего комита. `git checkout -- .` — откатить все файлы до последнего комита.
`git reset --soft HEAD^` — отменить комит и оставить изменения в Staging Area. Если сделали комит, но потом вспомнили, что там не все. `HEAD^` означает комит перед текущим. `--soft` говорит, что нужно оставить изменения в Staging Area.
`git commit --amend` — добавить изменения из Staging Area к предыдущему комиту. Если вдруг забыли добавить файл в сделаный комит. Можно даже перезаписать комит-сообщение: `git commit --amend -m "New commit message"`.
`git reset --hard HEAD^` — удалить последний комит и все изменения в нем. Нигде ничего не сохранится.

## Ветки
Ветка — это временная шкала с изменениями.
fast forward — слияние веток без изменений, когда люди делали разные дела и работали в разных файлах. 
recursive strategy — слияние веток, когда изменения есть в обоих ветках. Там комиты и тут комиты. Делается merge commit и изменения сливаются.
Merge commit — комит, который говорит, что призошло слияние веток.
Merge conflict возникает, когда нужно объединить изменения в одних и тех же файлах в одном и том же месте.
both modified — конфликт. При мерже двух веток в обоих есть изменения в одних и тех же местах в файле или файлах.
`git branch my-branch` — создать ветку, оставаясь в текущей ветке. `git checkout my-branch` — переключиться в ветку. Можно объединить эти два действия: `git checkout -b new-branch`.
`git push origin my-branch` — отправить ветку в удаленный репозиторий. Сопоставить локальный бранч с бранчем в удаленном репозитории.
`git push origin my-branch:other-name` — сделать так, чтобы локальный `my-branch` соответствовал ветке `other-name` на удаленном сервере. Сделать разные имена веток на локалке и на ремоуте.
`git branch -r` — покажет все ветки на удаленном репозитории. В них можно переходить `git checkout branchName` и они автоматически будут трекиться.
`git merge my-branch` — влить изменения из `my-branch` в рабочую ветку.
`git branch -d my-branch` — удалить локальную ветку. Как правило после добавления в мастер ветка не нужна.
`git push origin :my-branch` — удалить ветку из удаленного репозитория. Локально ветка останется.
При мерже веток по умолчанию Гит открывает редактор Vi. Выйти из него можно, нажав `q`. Сохранить изменения — `:wq`.
`git remote show origin` — покажет ветки, их соответствие и синхронизацию (up todate/out of date) с удаленными ветками. Если вдруг нельзя что-то запушить (кто-то удалил ветку на Гитхабе), то можно проверить список имеющихся веток.
`git remote prune origin` — почистить указатели на ветки, которые были удалены на Гитхабе. Полезно делать иногда на старом большом проекте. Локальные ветки останутся, но их сопоставление с ветками на Гитхабе обновится.

# Тэги
tag — референс на какой-то комит. Чтобы удобно было на него скакнуть. Часто теги используются для нумерации релизов.

Разобраться подробнее, как принято работать с тегами.

`git tag` — показать список тэгов.
`git checkout tagName` — переключиться на тэг (определенный именованный комит).
`git tag -a v0.0.1 "Version 0.0.1"` — добавить тег.
`git push --tags` — запушить тег. `--tags` — обязательный параметр. Если его не указать, то теги останутся локальными.

# Merge Commits и Rebase
Когда мержатся 2 ветки и в обоих есть комиты, то получается merge commit. Это точка на графе, которая, по сути, не несет никакой полезной нагрузки. Merge commit не про код, а чисто техническая деталь.

Чтобы избежать мерж-комитов можно делать ребейз.

При разрешении конфликтов так же делается Merge commit.

`git rebase` делает следующие вещи:
1. Переносит изменения из локальной ветки `master`, которых нет в `origin/master` во временную зону, чтобы получалось fast-forward при мерже локального и удаленного мастера.
2. Применяет все комиты из `origin/master`.
3. Применяет все локальные комиты из временной зоны (которые были в локальном мастере) по одному.
Таким образом не делается merge commit.

Локальный ребейз вместо мержа из ветки в мастер:
1. Переходим в ветку, из которой надо мержить в мастер: `git checkout my-branch`.
2. Запускаем `git rebase master`. Эта команда добавит все комиты из `master` в `my-branch`.
3. Переходим в `master` и мержим в него `my-branch`: `git merge my-branch`. Получается fast-forward.

# Удаление файлов
* `git rm "*.txt"` — удалить файлы (папки, файл) из репозитория и добавить удаление в комит.
* `git rm --cached mylogfile.log` — удалить файл из репозитория, но не удалять физически. `git rm --cached -r mydirectory` — то же самое для каталога.

# Добавление удаленного репозитория
`git remote add origin https://github.com/my-repo/my-repo.git` — добавть удаленный репозиторий. `git remote add <name> <address>`.
`origin` — общепринятое имя для удаленного репозитория. На самом деле оно может быть любым. И удаленных репозиториев может быть несколько.
`git remote -v` — список удаленных репозиториев.
`git remote rm <name>` — удалить удаленный репозиторий (связь локального репозитория с ним).
`git clone <url> [repo-local-name]` — клонировать существующий репозиторий. Remote назначается автоматически, текущая ветка устанавливается на `master`.

## Отправка изменений в удаленный репозиторий
`git push -u origin master` — отправить изменения в удаленный репозиторий. `-u` (upstream) говорит гиту, что нужно запомнить, что `origin` будет удаленным репозиторием по умолчанию и в следующий раз можно будет делать просто `git push` и гит поймет, в какой удаленный репозиторий нужно пушить.
`git diff <SHA>` — посмотреть различия того, что есть и того, что в комите `<SHA>`. `git diff HEAD` — ссылается на текущий бранч, как и `git diff`. Работает не только с комитами.
`git diff --staged` — посмотреть изменения, добавленные в staging area.

При попытке сделать пуш бывает ситуация, когда на сервере есть уже зафиксированные изменения от других разработчиков. Вы пытаетесь сделать пуш, а гит говорит `rejected (non-fast-forward)`. Это решается просто. Нужно стянуть эти измененя, сделав `git pull`.

# Получение изменений
`git pull origin master` — получить изменения из ветки `master` с удаленного репозитория. `git pull` стянет изменения со всех веток.

Шаги, которые делает git pull:
1. `git fetch` — стянуть все последние изменения и положить их в папку `.git`, не изменяя код. Не мержить. Синхронизировать изменения с удаленным репозиторием. В локальной копии (в папке .git), наряду с обычным локальным `master`, есть бранч `origin/master`. И в нем сохраняется все, что происходило в удаленном репозитории.
2. `git merge origin/master` — пытается смержить две ветки.

# Внимание!
* Не стоит изменять историю комитов, если они были запушены в удаленный репозиторий. Потом будут большие проблемы при получении изменений.
* Собранные файлы ресурсов (как правило папка `public/`) в репозитории не хранится (добавлена в `.gitignore`) и собирается у каждого разработчика отдельно. В `README.md` обычно есть инструкция по сборке ресурсов.

## TODO
* Работа с гитом в PHPStorm




