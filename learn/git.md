# Система контроля версий: Git и GitHub
Без системы контроля версий сложно представить современную разработку. Мы использует Гит и Гитхаб.

Нужно уметь работать с гитом из командной строки, понимать терминологию и общепринятые методики.

Программы с графическим интерфейсом ([PHPStorm](https://www.jetbrains.com/help/phpstorm/2016.1/using-git-integration.html), [GitHub Desktop](desktop.github.com), [Tower](https://www.git-tower.com/) и пр.) могут увеличить скорость работы, но применять их рекомендуется только после того, когда будет понятно, как работать с гитом из командной строки.

Без командной строки не обойтись, в гите слишком много операций, чтобы делать для них кнопки. GUI-инструменты стоит рассматривать как средства, упрощающие рутинные задачи, а не как полноценную замену командной строке.

Система контроля версий довольно сложная штука. Чтобы с ней хорошо разобраться нужно время. Запаситесь терпением, проходите разные курсы, читайте книги и не бойтесь задавать вопросы старшим товарищам. Лучше 10 раз переспросить и на 11-й понять, чем погрязнуть в дремучем неведении.

## Учебные материалы
### Курсы
* [Git Real I](https://www.codeschool.com/courses/git-real) — обязательно
* [Git Real II](https://www.codeschool.com/courses/git-real-2) — обязательно
* [Mastering GitHub](https://www.codeschool.com/courses/mastering-github)
* [GitHowTo](https://githowto.com/ru) — интерактивный тур по возможностям гита.
* [Learn Git Branching](http://learngitbranching.js.org/) — интерактивная обучалка по работе с ветками.
* [Git. Быстрый старт](https://geekbrains.ru/courses/66) — курс от GeekBrains (бесплатно).
* [Getting Git](https://vimeo.com/14629850) — часовое видео по введению в гит.
* [Гит для новичков](https://www.youtube.com/watch?v=PEKN8NtBDQ0) — видеокурс от LoftSchool.

### Книги
* [Pro Git](https://git-scm.com/book/ru/v2) — основная книга про Гит.
* [Become a git guru](https://www.atlassian.com/git/tutorials) — отличный учебник от Atlassian (они делают [Bitbucket](http://bitbucket.org)).

### Документация
* [Правила работы с Гитом в Oggetto](http://w.oggettoweb.com/index.php?title=%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_git)

## Инструменты
* [GitHub Desktop](https://desktop.github.com/) — графический интерфейс для Мака и Винды. Рекомендуется использовать для настройки ключей в гит-репозитории (просто залогиниться в программу под своим Гитхаб-аккаунтом и не надо заморачиваться с ssh-сертификатами). Как инструмент лучше использовать постоянно уже после уверенной работы с командной строкой.


## Документация
`git help` — документация по использованию гита.

`git help commit` — показать документацию по команде.


## История изменений
`git log` — показать список последних изменений. Можно искать (`/`), переходить к следующему вхождению (`n`). Это Vim в visual mode, как документация по команде в баше (например, `man ls`).

`git log --oneline -p` — показать историю коммитов с измененным кодом (`-p` — patch).

`git log --pretty=oneline` — выводить данные по комитам в одну строку.

`git log --pretty=format:"%h %ad- %s [%an]"` — задать свой формат вывода.

`%ad` — author date
`%an` — author name
`%h` — SHA hash
`%s` — subject
`%d` — ref names

`git log --oneline --stat` — показать кол-во вставок и удалений в измененных файлах.

`git log --oneline --graph` — показать в виде дерева. Показывает `*` — точки мержа (merge bubbles).

`git log --until=1.minute.ago` — последнюю минуту не учитывать
`git log --since=1.day.ago` — начиная со вчера
`git log --since=1.month.ago --until=1.day.ago` — месяц без вчерашнего дня (относительный промежуток).
`git log --since=2016-01-01 --until=2016-04-01` — с января по апрель (асболютный промежуток).

`git blame index.html --date short` — показать изменения в кажой строке файла с указанием автора изменений. Бывает полезно, когда трудно понять, откуда что взялось.

## Изменение и очистка истории
Нужна очень веская причина для изменения истории, если комиты уже отправлены в удаленный репозиторий. Если комиты есть только на вашей локалке, то все проще, но все равно нужно подумать.

В каких случаях стоит изменить историю?
* Случайно закомичен код, который нарушает какие-то договоры или лицензии.
* Случайно закомичены большие файлы, из-за которых репозиторий будет нереально много весить. Например, образ Вагранта, видео или psd-макеты.
* Если комиты сделаны только в локальном репозитории.

Нужно сделать бэкап. Клонировать репозиторий в отдельнуый каталог. Если вы работаете с изменениями в своем локальном репозитории — сделайте копию.

`git filter-branch --tree-filter <shell command>` — пройдется по всем комитам и выполнить заданную команду баша.

`git filter-branch --tree-filter 'rm -f passwords.txt'` — пройтись по ветке и удалить `passowrds.txt`.

`--tree-filter 'find . -name "*.mp4" -exec rm {} \;'` — удалит все файлы mp4. В эту команду можно добавить `--prune-empty`, чтобы не осталось пустых комитов после удаления файлов.

`git filter-branch -f <...>` — после первого выполнения гит создает бэкап. Если нужно выполнить команду второй раз, то он будет ругаться. `-f` — force, перезаписать бэкап.

`--tree-filter` будет чекаутить каждый комит, делать изменения и перекомичивать его. Если репозиторий большой, это может происходить очень долго. Вместо него можно использовать `--index-filter`.

`git filter-branch --index-filter <git command>` — в этом случае команда будет выполняться в staging area. Не будет чекаутить каждый комит и нужно использовать гит-команду вместо shell-команды.

`--index-filter 'git rm --cached --ignore-unmatch passwords.txt'` — так же удаляем `passwords.txt`.

`git filter-branch -f --prune-empty -- --all` — удалить пустые комиты (в которых никакие файлы не меняются). Пустые комиты могут остаться тогда, когда в удаленных комитах были изменения только в одном удаленном файле.

`filter-branch` имеет разные опции и нюансы. Подробнее вы можете почитать в `git help filter-branch` и пересмотреть [Git Real II, level 3](http://gitreal2.codeschool.com/levels/3).


## Настройка
`git config --list` — показать текущие настройки.

`~/.gitconfig` — файл конфигурации.

`git config --global core.editor sublime -n -w` — изменить редактор для редактирования сообщений в комитах.

`git config --global alias.lol "log --graph --decorate --pretty=oneline --abbrev-commit --all"` — задать аллиас для команды с опциями.

Рекомендуется настроить такие часто используемые алиасы:
```
st status
co checkout
br branch
ci commit
```

### Окончания строк в разных ОС
OS, Linux: LF (Line feed), `\n`.
Windows: CR (Carriage Return) + LF, `\r\n`. Пользователи Винды могут не видеть переводы строк в файлах, созданных на Линуксе или OSX.

`git config --global core.autocrlf input` — при коммите изменять CR/LF на LF. Пофиксит проблемы с переводом строк на Unix.

`git config --global core.autocrlf true` — изменит LF на CR/LF при чекауте, но вернет на LF при комите. Полезно на Винде.

Такого рода конфиги можно хранить в файле `.gitattributes`. Пример такого файла:
```
*      text=auto

*.html text
*.css  text

*.bat  text eol=crlf
*.sh   text eol=lf

*.jpg  binary
```

text — конвертить окончания строк в нужные при чекауте и при комите оставлять LF.

binary — никак не конвертировать.

## Cherry Pick
`git cherry-pick <SHA>` — вставить коммит с хэшем <SHA> в текущую ветку. Если нужно из другой ветки взять какой-то комит и положить в текущую ветку. После черрипика <SHA> взятого комита изменится. Он будет принадлежать уже текущей ветке.

При черрипике нам может быть нужно изменить commit message.

`git cherry-pick --edit <SHA>` — откроется редактор и можно будет изменить сообщение.

Иногда нужно черипикнуть сразу несколько комитов из другой ветки и вставить их в текущую одним комитом. Для этого есть опция `--no-commit`:

`git cherry-pick --no-commit <SHA1> <SHA2> ... <SHA5>` — взять изменения из перечисленных коммитов и добавить их в текущую ветку не делая комита. Его потом нужно сделать руками.

`--no-commit` удобно использовать, если нужно подредактировать код прежде чем вставить его из какой-то другой ветки (комита).

При черрипике _общедоступных веток_ хорошо указывать, откуда взять комит. Для локальных веток это не нужно, их же нету у других разработчиков. Опция `-x` сама вставит `<SHA>` исходного компита в commit message при черипике:

`git cherry-pick -x <SHA>`

`git cherry-pick --signoff <SHA>` — добавить имя пользователя, который изначально сделал комит. В логе в качестве автора комита будет указан тот, кто сделал черри-пик, а в качестве Signed-off-by будет указан оригинальный автор.


## Начало работы с репозиторием
`git init` — инициализировать репозиторий.

`git remote add origin https://github.com/my-repo/my-repo.git` — добавть удаленный репозиторий. `git remote add <name> <address>`.

`origin` — общепринятое имя для удаленного репозитория. На самом деле оно может быть любым. И удаленных репозиториев может быть несколько.

`git remote -v` — список удаленных репозиториев.

`git remote rm <name>` — удалить удаленный репозиторий (связь локального репозитория с ним).

`git clone <url> [repo-local-name]` — клонировать существующий репозиторий. Remote назначается автоматически, текущая ветка устанавливается на `master`.

`git clone repoDirName repoDirNameCopy` — можно клонировать локальные репозитории (для бэкапа, например).

## Термины
Папка `.git` — системная папка, в которой гит хранит историю и другую техническую информацию.

`staging area` — здесь хранятся изменения, которые попадут в репозиторий при комите.

`untracked` — файл существует, но не добавлен ни в репозиторий, ни в staging area.

`--` — интерпритируется [по разному в разных командах](http://stackoverflow.com/questions/22750028/in-git-what-does-dash-dash-mean). Как правило, отделяет опции от параметров (end of command line flags). Лучше обратится к документации для определенной команды, чтобы разобраться, что значит для нее `--`.

`SHA hash` — набор букв и цифр, идентифицирующих комит.

`HEAD` — указатель на текущий комит. По умолчанию ссылается на самый последний. `HEAD^` — предпоследний комит. Есть еще `HEAD^^` — пред-предпоследний комит.
`HEAD~5` — 5 комитов назад.

## Staging Area
`git add fileName` — добавить в SA.

`git add --all` — добавить все изменения и новые файлы в SA. Так же работает `git add .`.

`git reset myFile.html` — убрать добавленный в staging area файл из staging area. Изменеия в файле не потеряются, просто они не будут учтены при комите.

`git add *.txt` — добавить все файлы `.txt` из _текущего каталога_.

`git add "*.txt"` — добавить все файлы `.txt` _из всего проекта_.

## Commit
Сообщения о комитах добны быть в настоящем времени: Добавить файл, Изменить мыло. комит должен ответить на вопрос, что он делает, а не что он сделал. Подробнее см. в [Вики](http://w.oggettoweb.com/index.php?title=%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_git).

`git add` — добавить в staging area (подготовка).

`git commit -m "Add styles for header"` — добавляет в репозиторий изменения из staging area.

`git commit -am "Fix login error message"` — зафиксировать изменения в репозитории. `-a` — добавить в staging area изменения (чтобы не делать отдельно `git add`). `-m` — тут же в добавить сообщение.

`git commit --amend` — добавить изменения из Staging Area к предыдущему комиту. Если вдруг забыли добавить файл в сделаный комит. Можно даже перезаписать комит-сообщение: `git commit --amend -m "New commit message"`.

## Checkout
`git checkout -- filename.html` — убрать изменения в `filename.html` до последнего комита. Счекаутить его из `HEAD`.

Здесь `--` говорит, что не надо воспринимать `filename.html` как имя ветки. Отделяет опцию от параметра. Аналогично `git checkout HEAD filename.html`.

На самом деле `--` будет иметь значение, только когда файл и ветка будут назваться одинаково: `git checkout master` — чекаут ветки, `git checkout -- master` — чекаут файла.

`git checkout -- .` — откатить все файлы до последнего комита. 

Нужно помнить, что когда мы делмет что-то типа `git checkout HEAD^^`, мы перемещаем `HEAD` и текущая ветка остется без него (detached HEAD). Это можно делать, чтобы просто посмотреть, что было несколько комитов назад. Однако, делать комиты в таком положении нельзя. Либо нужно создавать из них новые ветки. Чекаутить комиты нужно осторожно, только для того, чтобы посмотреть, что в них было, но не менять.

## Reset
`git reset --soft HEAD^` — отменить комит и оставить изменения в Staging Area. Если сделали комит, но потом захотели внести изменения. `HEAD^` означает комит перед текущим. `--soft` говорит, что нужно оставить изменения в Staging Area.

`git reset` часто применяют на локальных ветках, откатывая изменения, не доступные другим. Начали делать, поняли, что нужно по-другому, резетнули и начали заново.

`git reset --hard HEAD^` — удалить _последний комит_ и все изменения в нем.

`git reset --hard <SHA>` — удалить коммит по хэшу.

На самом деле гит не удаляет комиты, хотя поесле `reset --hard` в логе их не будет. Однако, они есть в _локальком_ (вторичном) логе: `reflog`.

## Revert
`git revert HEAD^^` — взять комит `HEAD^^` и создает новый комит, который отменит изменения из `HEAD^^`.

Используется, если комит, изменения в котором нужно отменить, уже доступен другим (лежит на удаленном сервере).

## Ветки
Ветка — это временная шкала с изменениями.

`fast forward` — слияние веток без изменений, когда люди делали разные дела и работали в разных файлах. 

`recursive strategy` — слияние веток, когда изменения есть в обоих ветках. Там комиты и тут комиты. Делается merge commit и изменения сливаются.

Merge commit — комит, который говорит, что призошло слияние веток.

Merge conflict возникает, когда нужно объединить изменения в одних и тех же файлах в одном и том же месте.

both modified — конфликт. При мерже двух веток в обоих есть изменения в одних и тех же местах в файле или файлах.

`git branch my-branch` — создать ветку, оставаясь в текущей ветке. `git checkout my-branch` — переключиться в ветку. Можно объединить эти два действия: `git checkout -b new-branch`.

`git push origin my-branch` — отправить ветку в удаленный репозиторий. Сопоставить локальный бранч с бранчем в удаленном репозитории.

`git push origin my-branch:other-name` — сделать так, чтобы локальный `my-branch` соответствовал ветке `other-name` на удаленном сервере. Сделать разные имена веток на локалке и на ремоуте.

`git branch -r` — покажет все ветки на удаленном репозитории. В них можно переходить `git checkout branchName` и они автоматически будут трекиться.

`git merge my-branch` — влить изменения из `my-branch` в рабочую ветку.

`git branch -d my-branch` — удалить локальную ветку. Как правило после добавления в мастер ветка не нужна.

`git push origin :my-branch` — удалить ветку из удаленного репозитория. Локально ветка останется.

При мерже веток по умолчанию Гит открывает редактор Vi. Выйти из него можно, нажав `q`. Сохранить изменения — `:wq`.

`git remote show origin` — покажет ветки, их соответствие и синхронизацию (up todate/out of date) с удаленными ветками. Если вдруг нельзя что-то запушить (кто-то удалил ветку на Гитхабе), то можно проверить список имеющихся веток.

`git remote prune origin` — почистить указатели на ветки, которые были удалены на Гитхабе. Полезно делать иногда на старом большом проекте. Локальные ветки останутся, но их сопоставление с ветками на Гитхабе обновится.

# Тэги
tag — референс на какой-то комит. Чтобы удобно было на него скакнуть. Часто теги используются для нумерации релизов.

Разобраться подробнее, как принято работать с тегами.

`git tag` — показать список тэгов.
`git checkout tagName` — переключиться на тэг (определенный именованный комит).
`git tag -a v0.0.1 "Version 0.0.1"` — добавить тег.
`git push --tags` — запушить тег. `--tags` — обязательный параметр. Если его не указать, то теги останутся локальными.

# Merge Commits и Rebase
Когда мержатся 2 ветки и в обоих есть комиты, то получается merge commit. Это точка на графе, которая, по сути, не несет никакой полезной нагрузки. Merge commit не про код, а чисто техническая деталь.

Чтобы избежать мерж-комитов можно делать ребейз.

При разрешении конфликтов так же делается Merge commit.

`git rebase` делает следующие вещи:
1. Переносит изменения из локальной ветки `master`, которых нет в `origin/master` во временную зону, чтобы получалось fast-forward при мерже локального и удаленного мастера.
2. Применяет все комиты из `origin/master`.
3. Применяет все локальные комиты из временной зоны (которые были в локальном мастере) по одному.
Таким образом не делается merge commit.

Локальный ребейз вместо мержа из ветки в мастер:
1. Переходим в ветку, из которой надо мержить в мастер: `git checkout my-branch`.
2. Запускаем `git rebase master`. Эта команда положит отличающиеся от `master` коммиты во временную зону и добавит все комиты из `master` в `my-branch`. Таким образо `my-branch` будет такой же, как `master`.
3. Переходим в `master` и мержим в него `my-branch`: `git merge my-branch`. Получается fast-forward, нет merge-коммита.

## Продвинутый rebase
С помощью `rebase` можно объединить коммиты, разделить их, изменить комит-сообщение.

# Удаление файлов
* `git rm "*.txt"` — удалить файлы (папки, файл) из репозитория и добавить удаление в комит.
* `git rm --cached mylogfile.log` — удалить файл из репозитория, но не удалять физически. `git rm --cached -r mydirectory` — то же самое для каталога.

## Отправка изменений в удаленный репозиторий
`git push -u origin master` — отправить изменения в удаленный репозиторий. `-u` (upstream) говорит гиту, что нужно запомнить, что `origin` будет удаленным репозиторием по умолчанию и в следующий раз можно будет делать просто `git push` и гит поймет, в какой удаленный репозиторий нужно пушить.
`git diff <SHA>` — посмотреть различия того, что есть и того, что в комите `<SHA>`. `git diff HEAD` — ссылается на текущий бранч, как и `git diff`. Работает не только с комитами.
`git diff <SHA1>..<SHA2>` — сравнить два комита по SHA.
`git diff --staged` — посмотреть изменения, добавленные в staging area.
`git diff master dev` — сравнить 2 ветки.
С `git diff` можно использовать временные промежутки, как с `git log`.

При попытке сделать пуш бывает ситуация, когда на сервере есть уже зафиксированные изменения от других разработчиков. Вы пытаетесь сделать пуш, а гит говорит `rejected (non-fast-forward)`. Это решается просто. Нужно стянуть эти измененя, сделав `git pull`.

## Получение изменений
`git pull origin master` — получить изменения из ветки `master` с удаленного репозитория. `git pull` стянет изменения со всех веток.

Шаги, которые делает git pull:
1. `git fetch` — стянуть все последние изменения и положить их в папку `.git`, не изменяя код. Не мержить. Синхронизировать изменения с удаленным репозиторием. В локальной копии (в папке .git), наряду с обычным локальным `master`, есть бранч `origin/master`. И в нем сохраняется все, что происходило в удаленном репозитории.
2. `git merge origin/master` — пытается смержить две ветки.

## Исключение файлов и каталогов
Исключать файлы и папки, с которыми работают все разработчики на проекте (`node_modules`, `log` и пр.) нужно в `.gitignore`, который хранится в корне репозитория.

Исключить файлы и папки, которые касаются только вашего локального репозитория (свои заметки, какие-то справочные материалы) нужно в `.git/info/exclude`. Не стоит их добавлять в `.gitignore`, они никому кроме вас не нужны.

Чуть подробнее: https://habrahabr.ru/post/202696/

## Stash
Если в процессе работы нужно срочно переключится в другую ветку и что-то поправить, а коммитить текущую работу еще рановато, то можно воспользоваться `git stash`.

`git stash save` — сохранить текущие изменения не создавая комита во временной области. Вернуться к `HEAD`. После этого можно переключаться в ветку, где нужно что-то починить, текущая работа никуда не денется. Несколько таких сохранений добавляются в стэк. Просто `git stash` делает то же самое. Сохраняются и добавленные в Staging Area изменения и не добавленные. Работает только с tracked files. Файлы, еще не добавленные в репу, будут игнорироваться.

`git stash save --keep-index` — застэшить только те изменения, которые не добавлены в Staging Area (не добавлены для коммита).

`git stash save --include-untracked` — застэшить все файлы, в том числе те, которые еще не добавлены в репозиторий (untracked).

`git stash save "My stash message."` — можно добавить описание стэша при создании.

`git stash branch <new-branch-name> stash@{0}` — создать ветку из стэша и удалить этот стэш (как `pop`). Если вдруг ветка, в которой делался изначально стэш пропала (например, смержили и удалили).

`WIP` — Work In Progress.

`git stash list` — посмотреть список созданных стешей. Точнее последние комиты перед стешем (потому что стэш — это не комит).

`git stash list --stat` — показать статистику изменений в списке стэшей. А вообще работаю такие же опции, как у `git log`.

`git stash show stash@{1}` — показать статистику изменений в каком-то конкретном стэше. Без задания конкретного имени стэша покажет последний. Может использовать опции по аналогии с `git log`.

`git stash apply` — достать последние изменения, которые ранее были сохранены во временной области. `git stash apply stash@{1}` — достать определенный стэш. По умолчанию применяется `stash@{0}` — последний сохраненный в стэке, вызывается по умолчанию.

`git stash drop` — убрать последний стэш (`stash@{0}`). `git stash drop stash@{1}` — убрать один из стэшей.

`git stash pop` — сначала сделает `git stash apply` и потом `git stash drop`. Как `[1, 2, 3].pop()` в JS. Если вдруг будут конфликты, то `drop` не запустится, чтоб можно было еще раз попробовать. Тогда `drop` нужно будет вызвать руками.

`git stash clear` — удалить все стэши.

## Submodules
Субмодуль — это репозиторий внутри репозитория. Имеет свой свобственный удаленный репозиторий (адрес). Часто используется для подключения общего кода (библиотек). Разные проекты могут контрибьютить код в субмодули, пулить их. Таким образом вносим изменения в одном из проектов и все остальные его получают.

`git submodule add <repo address>` — добавит субмодуль в нужный каталог, создаст файл `.gitmodules`.

## Reflog
В гите ведется вторичный лог, который есть только в локальном репозитории — `git reflog`. Каждый раз, когда `HEAD` смещается, в него добавляется соответствующая запись: новый комит, чекаут ветки или резет.

`HEAD@{0}` — текущий комит в рефлоге.

`git reset --hard <SHA>` — если <SHA> — это резетнутый по ошибке комит, то его можно увидеть в рефлоге и таким образом достать из истории. Так же можно использовать `git reset --hard HEAD@{1}`.

Если удалили ветку с незакомиченным кодом: `git branch -D my-branch`. Гит удалит ветку, но коммиты он не удаляет.

`git log --walk-reflogs` — показать подробный рефлог.

Далее мы можем создать новую ветку из нужного коммита по <SHA>: `git branch my-recover-branch <SHA>`.


## Внимание!
* Собранные файлы ресурсов (как правило папка `public/`) в репозитории не хранится (добавлена в `.gitignore`) и собирается у каждого разработчика отдельно. В `README.md` обычно есть инструкция по сборке ресурсов.
* Не стоит изменять историю комитов, если они были запушены в удаленный репозиторий. Например, сделать `git checkout HEAD^^` и продолжать работать как ни в чем не бывало. Если вы работаете не один, то будут большие проблемы с синхронизацией изменений.

## TODO
* Работа с гитом в PHPStorm




