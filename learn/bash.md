# Командная строка
Командная строка — мощный инструмент для работы с файловой системой, вводом/выводом информации и автоматизацией.

Во фронтэнд-разработке часто используются инструменты, которые работают только из командной строки. При работе с конфигурациями сервера, ОС, разными пакетами нужно запускать в баше команды, редактировать файлы и переменные окружения. К этому нужно быть привычным и не испытывать благоговейного ужаса перед терминалом.

Иногда в проектах могут встречаться bash-скрипты (они же shell-скрипты, расширение `.sh`, подробнее можно почитать в [Википедии](https://ru.wikipedia.org/wiki/Bash)) и нужно уметь разобраться в том, что они делают. Например, иногда приходит верстка от олдовых чуваков, которые сборку кода делают не на Ноде, а на баше и надо просто понимать, как там все работает.

MacOS — это потомок FreeBSD, поэтому некоторые команды могут отличаться от принятых в Linux. Например, `tree` не работает в MacOS, а при работе с `sed` есть нюансы (см. ниже).

## Учебные материалы
### Курсы
* [Bash: Основы командной строки](https://ru.hexlet.io/courses/bash) — **обязательно для новичков**, рекомендуется для всех.
* [Learn the Command Line](https://www.codecademy.com/learn/learn-the-command-line) — рекомендуется для всех.

### Лекции
* [Командная строка Unix](https://events.yandex.ru/lib/talks/1292/) — бесплатно, рекомендуется для продвинутых разработчиков. Лекция от Школы Разработки Интерфейсов в Яндексе.

### Статьи
* [Основы Linux от основателя Gentoo (4 части)](https://habrahabr.ru/post/99041/)

## Краткое содержание с дополнениями
### Перемещение по файловой системе
`pwd` — показать путь к текущей директории (print working directory).
`cd` — change directory. Без параметров перемещает в домашнюю директорию.
`~` обозначает домашнюю директорию
`/` всегда обозначает корень. `/Hosts/projectName` — начнет искать от корня. Абсолютные пути начинаются со слеша.
`ls` — показать список файлов и каталогов.
`ls -t` — отсортировать по времени создания.
`ls -a` — показать скрытые файлы (начинающиеся с точки).
`ls -l` — long-формат (пользователь, права, время).
`ls -F` — отметить исполняемые файлы, папки и симлинки.
`tree dirname` — показывает файловую структуру в виде дереа. Работает на Линуксах, на Маке можно юзать `find dirname` или установить `brew install tree`.

### Копирование
`cp one.txt otherdir/` — скопировать one.txt в папку otherdir.
`cp * otherdir/` — скопировать все файлы из текущей папки в папку otherdir/
`cp m*.txt dir/` — скопировать файлы по шаблону.
`cp one.txt two.txt dir1/` — скопировать 2 файла в папку.

### Создание директорий
`mkdir dirName` — создать папку. Нельзя сделать вложенные папки.
`mkdir -p dirName/innerDir` — а с флагом `-p` можно создать вложенную структуру.

### Создание файлов
`touch filename` — создать файл. Можно и `touch dirname/filename`.

### Переименование
`mv currentName newName` — перемещение (переименование).

Чтобы руками каждый файл не переносить, можно использовать [glob](https://en.wikipedia.org/wiki/Glob_(programming))-подсстановки. Например, `mv firstDir/* secondDir`. Вместо `*` баш подставит весь список файлов из каталога `firstDir`.

### Удаление
`rm fileName` — удалить файл. Только файлы, директории не удалит.
`rm -r dirName` — а так удалить каталог. `-r` — рекурсивное удаление.

Удалить содержимое каталога:

1. Перейти в него и написать `rm *`. Или `rm dirName/*`. Если есть подкаталоги, то нужно использовать `rm -r dirName/*`.
2. `rm -r -f` то же, что и `rm -rf`. `-f` значит `force` — удалить не спрашивая подтверждения. Мак подтверждения не спрашивает, можно юзать просто `rm -r`, а на Линуксах может и спросить. Нужно быть аккуратнее с этой командой, восстановить удаленные файлы и папки не получится.

### Просмотр содержимого файлов
`cat` — вывести все содержимое файла в терминал.
`head` — вывести _первые_ 10 записей файла.
`tail` — вывети _последние_ 10 записей файла. `tail -f fileName` позволит видеть изменения в файле в реалтайме. Удобно смотреть логи.

`grep` (Global Regular Expression Print) — позволяет искать подстроку в файле. Например, `grep 'hello world' hello.txt`.
`grep -i 'HELLO' myfile.txt` — делает поиск регистронезависимым. Найдется и `hello` и `Hello` и `HELLO`.
`grep -Rl 'hello' /path/to/dir` — ищет во всех файлах в заданной директории. `-R` — рекурсивно. Флаг `-l` говорит, что нужно вывести только имена файлов, в которых найдена строка.

`sed` (stream editor) — найти и заменить. Принимает стандартный ввод, модифицирует его согласно регулярному выражению и выводит.
`sed s/snow/rain/ myfile.txt` — заменить `show` на `rain` в файле `myfile.txt`. `s` (substitution) говорит, что нужно заменять. При выводе содержимого из файла найдет все `snow` в файле и заменит их на `rain`. Не в файле, а именно при выводе. Такая конструкция заменяет только первое вхождение в строке. Если в строке 2 раза будет `snow`, то заменится только первый.
`sed s/snow/rain/g myfile.txt` — а так заменятся все вхождения `snow`. Флаг `-g` говорит, что поиск должен быть глобальным.
Если нужно заменить регистронезависимо, то в МакОС есть нюансы. Обычно, работает команда `sed -i s/snow/rain/g myfile.txt`. В МакОС так работать не будет. Она требует обязательного указания расширения для бэкап-файла: `sed -i .bk s/snow/rain/g myfile.txt`. См. http://stackoverflow.com/questions/4247068/sed-command-with-i-option-failing-on-mac-but-works-on-linux

### Пейджеры
Нужны для просмотра больших файлов. Можно перемещаться по содержимому и оно будет подгружаться. Даже огромные файлы быстро открываются.

`less fileName` — мы попадаем в визуальный режим Вима, работают многие команды. В том числе `q` для выхода и `h` для хелпа.

### Документация
`man` — команда, которая запускает документация для команд баша. Открываются обычно сразу в пейджере. Например, `man node` — мануал по запуску Ноды.

Разные команды могут быть использованы в разном контексте: как программный вызов из баша, как вызов и программы на Си и пр. `man -f mkdir` — показать все категории команды.

### Переменные окружения
Любая команда — это программа, которая где-то лежит. Например, `which ls` покажет, какой файл физически будет запущен для вывода листинга текущей директории. Баш узнает о положении этих файлов из переменной окружения.

```bash
VAR=3
echo $VAR # при выводе перед переменной нужно ставить $
```

`env` — показать все переменные окружения в текущей сессии.

`$PATH` — содержит набор путей, по которым ищется программа в баше. Пути разделены двоеточием. См. `echo $PATH`.

`PATH=/some/path:$PATH` — добавить путь в конец `PATH` на время текущей сессии.

Переменные окружения можно использовать в программах. Как правило они устанавливается инлайново при запуске: `MYVAR=10 my_program`. Переменная будет жива только в течение текущей сессии.

Чтобы установить переменную для всех, нужно ее экспортировать: `export MYVAR=10`.

`unset MYVAR` — удалить переменную окружения из текущей сессии.

### Сессии
Когда мы запускаем окно терминала, мы создаем новую сессию. В разных сессиях могут быть запущены разные процессы. При создании сессии подгружаются разные настройки для работы с терминалом: алиасы, внешний вид терминала, переменные окружения и пр. Совокупность всех этих настроек называются окружением (environment).

Чтобы сохранить настройки окружения в МакОС для последующих сессий их нужно записать в `~/.bash_profile` — скрытый системный файл в директории пользователя. Для Линукса больше подойдет `~/.bashrc`. В чем разница, можно почитать [тут](http://www.joshstaiger.org/archives/2005/07/bash_profile_vs.html).

Команда `source` активирует настройки окружения в текущей сессии. Внесли изменения в `~/.bash_profile`, запустили `source ~/.bash_profile` и изменения заработали, не нужно открывать новую вкладку терминала.

### Перенаправления и потоки
`STDOUT` — стандартный поток вывода. Информация, выводимая в терминал после выполнения команд (процессов). В него программы выводят результат своего выполнения. Это стандартная работа баша — вывести на экран. Но можно перенаправить этот вывод в файл: `ls > output.txt`.

`STDIN` — стандартный поток ввода. То, что мы вводим в терминале с клавиатуры или других девайсов. Из него можно брать информацию.

Например, есть текстовый файл `unsorted.txt`. Строки в этом файле можно отсортировать и вывести на экран так: `sort < unsorted.txt`. Или записать в файл: `sort < unsorted.txt > sorted.txt`.

Есть еще `STDERR` — сообщения об ошибках, если не получается выполнить процесс или команду в терминале.

Мы можем перенаправлять потоки `STDIN`, `STDOUT` и `STDERR`. Например, выводить что-то не в терминал, а сохранять в файл.

`>` — отправить стандартный вывод в файл, а не на терминал. Если файл уже есть, то он перезапишется.

`>>` — дописать стандартный вывод в конец файла. Если файл существует, то он не затрется, как при `>`.

`<` — взять стандартные вывод из файла справа и отдать его команде слева: `sort < unsorted.txt`.

Конвейер (pipeline) — перенаправление STDOUT одного процесса в STDIN другого. Можно передавать данные из программы в программу на лету, для этого используется символ `|`. Например: `cat unsorted | sort | uniq` — прочитать из файла, отсортировать и показать только уникальные занчения.

`|` — pipe, передает данные из команды в команду. Берет стандартный вывод от команды слева и передает его в команду справа: `cat my_file.txt | wc`.

`uniq` — убирает дублирующиеся строки, если они идут подряд, а не в разброс. Для этого надо сначала отсортировать с помощью `sort`.

Конвейер часто используют с `grep`, когда нужно найти часть данных:
`ls | grep config | grep js`.


`wc` — word count. Показывает кол-во строк, слов и букв. `ls | wc`. Есть флаги, позволяющие показывать только строки, слова или буквы (`-l`).

### История
История команд сохраняется в `~/.bash_history`.

`reset` — сбросить текущий терминал (очистить полностью).

`history` —  вывести всю историю команд. Каждая команда имеет номер.

`!323` — запустить команду под номером 323.

`!cat` — выполнить первую с конца истории команду, которая начинается с `cat`.

`!!` — запустить последнюю команду. Удобно, если нужно добавить `sudo`, когда не прокатил запуск под текущим пользователем. Ну чтоб заново не набирать:
```bash
vim /etc/hosts # Не получается изменить... А, блин, sudo забыл.
sudo !! # А так уже получится.
```

`Ctrl+R` — инкрементальный поиск по всей истории. Инкрементальный, значит по ходу набора части команды идет ее поиск в истории. Если выводится не то, можно продолжать нажимать `Ctrl+R` и подстановка будет обновляться.

### Псевдонимы
Некоторые команды очень часто используются с одними и теми же аргументами. Чтобы сэкономить время можно настроить для них псевдонимы (алиасы).

Так же в алиасы можно сохранить пути. Например, для специфической версии PHP, исполняемый файл которой лежит в нестандартном месте (как в [MAMP](https://www.mamp.info/en/)).

`alias` — выведет список всех псевдонимов.

`alias ll='ls -alF'` — для вывода списка файлов с полной информацией (-l), файлов с точками (-a) в начале и отметить исполняемые *, папки / и симлинки @ (-F).

`unalias ll` — удалить алиас.

`type ll` — выведет команду, на которую ссылается алиас, если вдруг забыли, что там.

Чтобы алиас не терялся по завершению текущей сессии, его нужно добавить в `~/.bash_profile`.


# В процессе

### Пакетные менеджеры на Mac OS
Пакетные менеджеры помогают автоматизировать процесс установки разных программ и утилит, которые работают из командной строки. В Mac OS чаще всего используют [Brew](http://brew.sh/).

### sudo
Чтобы что-то сделать в баше с правами администратора нужно использовать команду `sudo`.

### chmod
`-u` user, `-g` group, `-o` other
`+` — если надо добавить привелегий
`rwx` - чтение (read), запись (write), исполнение (execute)
`chmod gou+rwx fileName.txt`
`chmod u-w fileName.txt` — убрать write у юзера

Цифровое представление:
```
4 — read
2 - write
1 - execute
0 - none

7 = 4 + 2 + 1 = read + write + execute
6 = 4 + 2 = read + write
5 = 4 + 1 = read + execute
3 = 2 + 1 = write + execute
```

`chmod 777 ~/Hosts/project/var` — юзер, группа и остальные могут читать, писать и исполнять.
`chmod 764` — юзер может все, группа может читать и писать, гости могут только читать.

Каталог должен иметь execute и read, чтобы его можно было открывать и перемещаться по нему. Если execute не будет, то его нельзя будет открыть.

Категории пользователей: user, group, other. other — это типа гостей, которые не пренадлежат группе и не являются пользователями.

убрать привелегии:
`sudo chmod o-w fileName.txt` — other remove write

`-R` — пройтись по содержимому каталога и всем подкаталогам и файлам изменить права: `chmod -R 777 var` — изменить доступ папке var и всем ее подкаталогам и файлам.

### Символические ссылки
Символическая ссылка (симлинки, symbolyc links) содержит указатель (путь) на файл, который нужно открыть при обращении. С помощью симлинков удобно создавать дубликаты файлов, шорткаты для запуска программ. При удалении симлинка исходный файл остается на месте. При удалении исходного документы ссылка так же останется на месте. При перемещении исходного файла симлинк не обновляется.

`ln -s /path/to/original /path/to/symlink` — создать симлинк (параметр `-s`).

Например, можно [назначить шорткат](http://olivierlacan.com/posts/launch-sublime-text-3-from-the-command-line/) на запуск любимого текстового редактора из командной строки. 

### chown
Изменить владельца файла или папки.

### open
`open .` — открыть текущую папку в Finder. То же самое для файла: `open some/file.html`.

